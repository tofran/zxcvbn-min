{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/adjacency_graphs.coffee",
    "src/feedback.coffee",
    "src/frequency_lists.coffee",
    "src/main.coffee",
    "src/matching.coffee",
    "src/scoring.coffee",
    "src/time_estimates.coffee"
  ],
  "names": [],
  "mappings": "AAAA;ACAyD,IAAA,iBACzD,iBACE,CAAA,OAAQ,CAAC,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAM,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,MAAO,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,MAAO,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,MAAO,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,MAAO,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,KAAM,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,MAAO,KAAM,OAAQ,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,MAAO,KAAM,OAAQ,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,OACx9H,OAAQ,CAAC,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,IAAM,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,MAAO,KAAM,MAAO,IAAK,CAAC,MAAO,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,OAAQ,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,MAAO,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,MAAO,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,OAAQ,EAAK,CAAC,KAAM,MAAO,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,KAAM,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,MAAO,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,OACx9H,OAAQ,CAAC,IAAK,CAAC,IAAK,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,KAAM,IAAK,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,IAAK,CAAC,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,KAAM,EAAK,CAAC,KAAM,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,KAAM,MAAO,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAAO,EAAK,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,EAAK,CAAC,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,IAAK,MAAO,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,IAAK,KAAM,EAAK,CAAC,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,MAAO,EAAK,CAAC,IAAK,KAAM,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,IAAK,MAChvB,WAAY,CAAC,IAAK,CAAC,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,IAAK,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,IAAK,KAAM,IAAK,CAAC,IAAK,IAAK,IAAK,KAAM,KAAM,KAAM,KAAM,MAAO,IAAK,CAAC,IAAK,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,KAAM,EAAK,CAAC,KAAM,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,MAAO,EAAK,CAAC,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,KAAM,MAAO,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAAO,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,KAAM,KAAM,IAAK,KAAM,EAAK,CAAC,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,IAAK,MAAO,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,IAAK,KAAM,EAAK,CAAC,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,IAAK,MAAO,EAAK,CAAC,IAAK,KAAM,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,EAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAAM,IAAK,CAAC,KAAM,KAAM,KAAM,KAAM,IAAK,IAAK,IAAK,OAEryB,OAAO,QAAU;;;ACPjB,IAAA,SAAA,QAAA,QAAU,QAAQ,aAElB,SACE,CAAA,iBACE,CAAA,QAAS,GACT,YAAa,CACX,wCACA,sDAGJ,aAAc,SAAC,EAAO,GACxB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACI,GAA+C,IAAnB,EAAS,OAArC,OAAO,KAAC,iBAGD,GAAG,EAAQ,QAChB,CAAA,QAAS,GACT,YAAa,IAIf,IADA,EAAgB,EAAS,GACzB,EAAA,EAAA,GAAA,EAAA,EAAA,MAAA,IAAA,OAAA,EAAA,EAAA,aACiC,MAAM,OAAS,EAAc,MAAM,SAAlE,EAAgB,UAElB,EAAiB,sDACd,OAFH,SAAW,KAAC,mBAAmB,EAAkC,IAAnB,EAAS,UAGrD,SAAS,YAAY,QAAQ,GACA,MAAA,SAAA,UAA7B,SAAS,QAAU,KAEnB,SACE,CAAA,QAAS,GACT,YAAa,CAAC,IAClB,UAEF,mBAAoB,SAAC,EAAO,GAC1B,OAAO,EAAM,SAAb,IACO,oBACH,KAAC,8BAA8B,EAAO,GAF1C,IAIO,iBACM,EAAM,MAAM,cAKrB,CAAA,QAJ4B,IAAf,EAAM,MACjB,0CAEA,4CAEF,YAAa,CACX,kDAZN,IAeO,eAKH,CAAA,QAJwC,IAA3B,EAAM,WAAW,OAC5B,uCAEA,wEAEF,YAAa,CACX,wCAtBN,IAyBO,iBACH,CAAA,QAAS,+CACT,YAAa,CACX,oBA5BN,IA+BO,QACH,GAAuB,gBAApB,EAAM,iBACP,CAAA,QAAS,iCACT,YAAa,CACX,qBACA,6CALD,MA/BP,IAuCO,aACH,CAAA,QAAS,gCACT,YAAa,CACX,yDAGR,8BAA+B,SAAC,EAAO,GACzC,IAAA,EAAA,EAAA,EAAA,SAAI,EAAsC,cAAzB,EAAM,iBACd,GAAsB,EAAM,MAAa,EAAM,SAO1C,EAAM,eAAiB,EAC7B,mDADG,EANA,EAAM,MAAQ,GACf,mCACM,EAAM,MAAQ,IACpB,oCAEA,iCAG2B,sBAAzB,EAAM,gBACT,EACD,yCADF,EAEgC,cAH7B,EAGG,EAAM,kBAAgC,eAAtC,GAAoD,iBAApD,EACH,EACD,qDAEA,8CAEF,GAEF,EAAc,IACd,EAAO,EAAM,OACL,MAAM,QAAQ,aACpB,EAAY,KAAK,yCACX,EAAK,MAAM,QAAQ,YAAe,EAAK,gBAAiB,GAC9D,EAAY,KAAK,6DAEhB,EAAM,UAAa,EAAM,MAAM,QAAU,GAC1C,EAAY,KAAK,8CAChB,EAAM,MACP,EAAY,KAAK,0EAGjB,CAAA,QAAS,EACT,YAAa,KAGnB,OAAO,QAAU;;;ACvHsB,IAAA,gBACvC,gBACE,CAAA,UAAW,GACX,kBAAmB,GACnB,aAAc,GACd,SAAU,GACV,eAAgB,GAChB,WAAY,IACd,OAAO,QAAU;;;ACRjB,IAAA,SAAA,SAAA,QAAA,KAAA,eAAA,OAAA,SAAW,QAAQ,cACnB,QAAU,QAAQ,aAClB,eAAiB,QAAQ,oBACzB,SAAW,QAAQ,cAEnB,KAAO,kBAAG,IAAK,MAAQ,WAEvB,OAAS,SAAC,EAAU,EAAc,IAClC,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAGE,IAHA,EAAQ,OAER,EAAmB,GACnB,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IACoB,WAAlB,mBAA4B,WAAzB,GAAmC,YAAnC,GACD,EAAiB,KAAK,EAAI,WAAW,eAMzC,IAAA,KALA,SAAS,0BAA0B,GACnC,EAAU,SAAS,UAAU,IAC7B,EAAS,QAAQ,8BAA8B,EAAU,IAClD,UAAY,OAAS,EAC5B,EAAe,eAAe,sBAAsB,EAAO,gBAEzD,EAAO,GAAQ,SACjB,EAAO,SAAW,SAAS,aAAa,EAAO,MAAO,EAAO,UAC7D,GAEF,OAAO,QAAU;;;ACxBjB,IAAA,cAAA,cAAA,YAAA,OAAA,WAAA,oBAAA,QAAA,iBAAA,kBAAA,gBAAA,IAAA,SAAA,KAAA,QAaA,IAAA,QAbA,gBAAkB,QAAQ,qBAC1B,iBAAmB,QAAQ,sBAC3B,QAAU,QAAQ,aAElB,kBAAoB,SAAC,GACrB,IAAA,EAAA,EAAA,EAAA,EAEE,IAFA,EAAS,GACT,EAAI,EACJ,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IACE,QAAe,EACf,GAAK,SACP,GAEF,oBAAsB,GACtB,0CACE,oBAAoB,MAAQ,kBAAkB,KAEhD,OACE,CAAA,OAAY,iBAAiB,OAC7B,OAAY,iBAAiB,OAC7B,OAAY,iBAAiB,OAC7B,WAAY,iBAAiB,YAE/B,WACE,CAAA,EAAG,CAAC,IAAK,KACT,EAAG,CAAC,KACJ,EAAG,CAAC,IAAK,IAAK,IAAK,KACnB,EAAG,CAAC,KACJ,EAAG,CAAC,IAAK,KACT,EAAG,CAAC,IAAK,IAAK,KACd,EAAG,CAAC,IAAK,IAAK,KACd,EAAG,CAAC,KACJ,EAAG,CAAC,IAAK,KACT,EAAG,CAAC,IAAK,KACT,EAAG,CAAC,KACJ,EAAG,CAAC,MAEN,QACE,CAAA,YAAc,uBAEhB,cAAgB,KAChB,cAAgB,IAChB,YACE,CAAA,EAAE,CACA,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,EAAE,CACA,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,EAAE,CACA,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,EAAE,CACA,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,EAAE,CACA,CAAC,EAAG,GACJ,CAAC,EAAG,KAGR,SACE,CAAA,MAAO,SAAC,GAAO,IAAA,SAA4B,IAA3B,iBAAC,IAAA,KAAA,EAAA,GAAA,SAAA,YAAD,GAAiB,QACjC,OAAQ,SAAC,EAAK,UAAS,EAAI,KAAK,MAAM,EAAK,IAC3C,UAAW,SAAC,EAAQ,GAAW,IAAA,SAAC,uBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,MAAA,KAAA,OAAA,EAAA,EAAA,kBAAA,EAAQ,IAAQ,YAAjB,GAAkD,KAAK,KACvF,IAAK,SAAC,EAAG,UAAQ,EAAI,EAAK,GAAK,GAC/B,OAAQ,SAAC,UAEP,EAAQ,KAAK,SAAC,EAAI,UACf,EAAG,EAAI,EAAG,GAAO,EAAG,EAAI,EAAG,KAMhC,UAAW,SAAC,GACd,IAAA,EAAA,EAAA,EAAA,EAAA,EAWI,IAXA,EAAU,GAWV,EAAA,EAAA,GAVA,EAAW,CACT,KAAC,iBACD,KAAC,yBACD,KAAC,WACD,KAAC,cACD,KAAC,aACD,KAAC,eACD,KAAC,YACD,KAAC,aAEH,OAAA,EAAA,EAAA,WACE,KAAC,OAAO,EAAS,EAAQ,KAAK,KAAM,WACtC,KAAC,OAAO,IAMV,iBAAkB,SAAC,EAAU,EAAuB,qBACtD,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAII,IAAA,KAHA,EAAU,GACV,EAAM,EAAS,OACf,EAAiB,EAAS,cAC1B,EACE,WAAS,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,IAAS,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACJ,EAAc,MAAA,GAAA,EAAA,GAAA,OAAU,IAEzB,EAAO,EADP,EAAO,EAAc,MAAA,GAAA,EAAA,GAAA,MAErB,EAAQ,KACN,CAAA,QAAS,aACT,EAAG,EACH,EAAG,EACH,MAAO,EAAQ,MAAA,GAAA,EAAA,GAAA,KACf,aAAc,EACd,KAAM,EACN,gBAAiB,EACjB,UAAU,EACV,MAAM,YAChB,KAAC,OAAO,IAEV,yBAA0B,SAAC,EAAU,EAAuB,qBAC9D,IAAA,EAAA,EAAA,EAAA,EAAA,EAEI,IAFA,EAAoB,EAAS,MAAM,IAAI,UAAU,KAAK,IAEtD,EAAA,EAAA,GADA,EAAU,KAAC,iBAAiB,EAAmB,IAC/C,OAAA,EAAA,EAAA,aACQ,MAAQ,EAAM,MAAM,MAAM,IAAI,UAAU,KAAK,IACnD,EAAM,UAAW,GAEhB,EAAM,EAAG,EAAM,GAAK,CACnB,EAAS,OAAS,EAAI,EAAM,EAC5B,EAAS,OAAS,EAAI,EAAM,UAEhC,KAAC,OAAO,IAEV,0BAA2B,SAAC,UAC1B,oBAAmB,YAAkB,kBAAkB,EAAa,UAOtE,uBAAwB,SAAC,EAAU,GACrC,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACI,IADA,EAAiB,GACjB,EAAA,EAAA,GAAA,EAAA,EAAA,MAAA,KAAA,OAAA,EAAA,EAAA,WACE,EAAe,IAAO,EAExB,IAAA,KADA,EAAW,GACX,UACE,EAAA,qBAAiB,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,eAAgC,UAAhC,YAAjB,IACiB,OAAS,IACxB,EAAS,GAAU,UACvB,GAGF,oBAAqB,SAAC,GACxB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAyCI,IAzCA,EAAA,iBAAQ,IAAA,KAAA,EAAA,GAAA,SAAA,YAAR,GACA,EAAO,CAAC,IAER,EAAQ,SAAC,GACb,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAEM,IAFA,EAAU,GACV,EAAU,GACV,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,YACE,EAAA,qBAAS,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,gBAAA,CAAC,EAAE,aAAZ,IACM,QACN,EAAQ,qBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,gBAAA,EAAE,IAAI,YAAP,GAA2B,KAAK,QACxB,IACd,EAAQ,IAAS,EACjB,EAAQ,KAAK,WACjB,IAEF,EAAS,SAAC,GACd,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAM,GAAc,EAAK,OAAnB,CAIA,IAHA,EAAY,EAAK,GACjB,EAAY,EAAI,MAAA,GAChB,EAAY,GACZ,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,OAAA,EAAA,EAAA,IACE,WAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,CAEE,IADA,GAAkB,EACT,EAAA,EAAA,EAAA,WAAA,OAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,GAAG,EAAI,GAAG,KAAM,EAAhB,CACE,EAAiB,EACjB,OACkB,IAAnB,GACD,EAAgB,EAAI,OAAO,CAAC,CAAC,EAAU,KACvC,EAAU,KAAK,MAEf,EAAkB,EAAI,MAAM,IACZ,OAAO,EAAgB,GACvC,EAAgB,KAAK,CAAC,EAAU,IAChC,EAAU,KAAK,GACf,EAAU,KAAK,WACrB,EAAO,EAAM,GACb,EAAO,MAEF,GACP,EAAY,GACZ,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,CAEE,IADA,EAAW,GACX,EAAA,EAAA,WAAA,OAAA,EAAA,EAAA,KAAK,EAAU,GAAX,EAAA,GACF,EAAS,GAAY,EACvB,EAAU,KAAK,UACjB,GAEF,WAAY,SAAC,EAAU,EAAuB,oBAAqB,EAAc,YACnF,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACI,IADA,EAAU,GACV,EAAA,EAAA,GAAA,EAAA,KAAA,oBAAA,KAAA,uBAAA,EAAA,KAAA,OAAA,EAAA,YACW,KAAC,MAAM,IADlB,IAGE,IADA,EAAkB,KAAC,UAAU,EAAU,GACvC,EAAA,EAAA,GAAA,EAAA,KAAA,iBAAA,EAAA,IAAA,OAAA,EAAA,EAAA,IAEE,WADA,EAAQ,EAAQ,MAAA,EAAA,GAAA,EAAA,EAAA,GAAA,MACP,gBAAiB,EAAM,aAAhC,CAGA,IAAA,KADA,EAAY,GACZ,UAA8D,IAA9B,EAAM,QAAQ,KAC5C,EAAU,GAAc,GAC1B,EAAM,MAAO,EACb,EAAM,MAAQ,EACd,EAAM,IAAM,EACZ,EAAM,YAAc,iBAAC,IAAA,KAAA,EAAA,GAAA,mBAAG,QAAQ,cAAZ,GAAsC,KAAK,MAC/D,EAAQ,KAAK,UACjB,KAAC,OAAO,EAAQ,OAAO,SAAC,UAItB,EAAM,MAAM,OAAS,MAMzB,cAAe,SAAC,EAAU,EAAU,QACtC,IAAA,EAAA,EAAA,EACI,IAAA,KADA,EAAU,GACV,SACE,KAAC,OAAO,EAAS,KAAC,qBAAqB,EAAU,EAAO,WAC1D,KAAC,OAAO,IAEV,WAAY,oDACZ,qBAAsB,SAAC,EAAU,EAAO,GAC1C,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAEI,IAFA,EAAU,GACV,EAAI,EACE,EAAI,EAAS,OAAS,GAS1B,IARA,EAAI,EAAI,EACR,EAAiB,KACjB,EAAQ,EAKN,EAJgB,WAAf,GAAyB,WAAzB,IAAuC,KAAC,WAAW,KAAK,EAAS,OAAO,IAIzD,EAFA,IAGlB,CAOE,GALA,GAAQ,EACR,GAAmB,EACnB,GAAiB,EACjB,EAAY,EAJA,EAAS,OAAO,EAAE,KAIE,GAE7B,EAAI,EAAS,OAEd,IADA,EAAW,EAAS,OAAO,GAC3B,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAEE,GADA,GAAiB,aACoB,IAA1B,EAAI,QAAQ,GAAvB,CACE,GAAQ,EACR,EAAkB,EACU,IAAzB,EAAI,QAAQ,KAKb,GAAiB,GAChB,IAAkB,IAGnB,GAAS,EACT,EAAiB,GACnB,MAEN,IAAG,EAAH,CAIK,EAAI,EAAI,GACT,EAAQ,KACN,CAAA,QAAS,UACT,EAAG,EACH,EAAG,EAAE,EACL,MAAO,EAAQ,MAAA,EAAA,GACf,MAAO,EACP,MAAO,EACP,cAAe,IAEnB,EAAI,EACJ,MAdA,GAAK,SAeX,GAMF,aAAc,SAAC,GACjB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAKI,IALA,EAAU,GACV,EAAS,WACT,EAAO,YACP,EAAgB,aAChB,EAAY,EACN,EAAY,EAAS,SACzB,EAAO,UAAY,EAAK,UAAY,EACpC,EAAe,EAAO,KAAK,GAC3B,EAAa,EAAK,KAAK,GACV,MAAA,IACV,EAAa,GAAG,OAAS,EAAW,GAAG,QAIxC,EAAQ,EAKR,EAAa,EAAc,KAAK,EAAM,IAAI,IAM1C,GADA,EAAQ,GACW,IACpB,EAAG,GAAK,CAAC,EAAM,MAAO,EAAM,MAAQ,EAAM,GAAG,OAAS,GAMvD,GAJA,EAAgB,QAAQ,8BACtB,EACA,KAAC,UAAU,KAEgB,SAC7B,EAAe,EAAc,QAC7B,EAAQ,KACN,CAAA,QAAS,SACT,EAAG,EACH,EAAG,EACH,MAAO,EAAM,GACb,WAAY,EACZ,aAAc,EACd,aAAc,EACd,aAAc,EAAM,GAAG,OAAS,EAAW,SAC7C,EAAY,EAAI,SAClB,GAEF,UAAW,EACX,eAAgB,SAAC,GACnB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAaI,GAAgC,IAAnB,EAAS,OAAtB,MAAO,GAiCP,IA/BA,EAAS,EAAC,EAAG,EAAG,KACpB,IAAA,EAAA,EAAA,EAAA,EAAM,IAAG,EAAI,EAAI,GAAwB,IAAnB,KAAK,IAAI,KACpB,GAAA,EAAI,KAAK,IAAI,KAAb,GAAuB,KAAC,iBACzB,EAAQ,EAAQ,MAAA,GAAA,EAAA,GAAA,KACb,WAAW,KAAK,IACjB,EAAgB,QAChB,EAAiB,IACX,WAAW,KAAK,IACtB,EAAgB,QAChB,EAAiB,IACX,QAAQ,KAAK,IACnB,EAAgB,SAChB,EAAiB,KAIjB,EAAgB,UAChB,EAAiB,IACnB,EAAO,KACL,CAAA,QAAS,WACT,EAAG,EACH,EAAG,EACH,MAAO,EAAQ,MAAA,GAAA,EAAA,GAAA,KACf,cAAe,EACf,eAAgB,EAChB,UAAW,EAAQ,MAE3B,EAAS,GACT,EAAI,EACJ,EAAa,KAEJ,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,EAAQ,EAAS,WAAW,GAAK,EAAS,WAAW,EAAI,GAClD,MAAA,IACL,EAAa,GACH,IAAS,IAErB,EAAO,EADP,EAAI,EAAI,EACK,GACb,EAAI,EACJ,EAAa,UACf,EAAO,EAAG,EAAS,OAAS,EAAG,GAC/B,GAMF,YAAa,SAAC,EAAU,EAAW,SACrC,IAAA,EAAA,EAAA,EAAA,EACI,IAAA,QADA,EAAU,GACV,EAEE,gBADM,UAAY,EACZ,EAAW,EAAM,KAAK,IAC1B,EAAQ,EAAS,GACjB,EAAQ,KACN,CAAA,QAAS,QACT,MAAO,EACP,EAAG,EAAS,MACZ,EAAG,EAAS,MAAQ,EAAS,GAAG,OAAS,EACzC,WAAY,KACZ,YAAa,WACnB,KAAC,OAAO,IAMV,WAAY,SAAC,GACf,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EA+BI,IAbA,EAAU,GACV,EAA0B,YAC1B,EAA4B,+CAWnB,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,IAAS,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,MACE,GAAK,EAAS,QADhB,EAAA,GAAA,IAAA,IAAA,EAGP,GADA,EAAQ,EAAQ,MAAA,GAAA,EAAA,GAAA,KACA,EAAwB,KAAK,GAA7C,CAEA,IADA,EAAa,GACb,EAAA,EAAA,GAAA,EAAA,YAAA,EAAA,SAAA,OAAA,EAAA,EAAA,KAAK,EAAE,GAAH,EAAA,GAMqB,OALvB,EAAM,KAAC,gBAAgB,CACrB,SAAS,EAAK,MAAA,EAAA,IACd,SAAS,EAAK,MAAA,EAAA,IACd,SAAS,EAAK,MAAA,QAEhB,EAAW,KAAK,GAClB,GAAgB,EAAW,OAAS,EAApC,CAUA,IAHA,EAAiB,EAAW,GAE5B,GADA,EAAS,SAAC,UAAc,KAAK,IAAI,EAAU,KAAO,QAAQ,kBACpC,EAAW,IACjC,EAAA,EAAA,GAAA,EAAA,EAAA,MAAA,IAAA,OAAA,EAAA,EAAA,KACE,EAAW,WACG,KACX,EAAgB,GAAgB,CAAC,EAAW,IACjD,EAAQ,KACN,CAAA,QAAS,OACT,MAAO,EACP,EAAG,EACH,EAAG,EACH,UAAW,GACX,KAAM,EAAe,KACrB,MAAO,EAAe,MACtB,IAAK,EAAe,OAG1B,IAAS,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,IAAS,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,MACE,GAAK,EAAS,QADhB,EAAA,GAAA,IAAA,IAAA,EAEP,EAAQ,EAAQ,MAAA,GAAA,EAAA,GAAA,KAEA,OADhB,EAAW,EAA0B,KAAK,KAO1B,OALhB,EAAM,KAAC,gBAAgB,CACrB,SAAS,EAAS,IAClB,SAAS,EAAS,IAClB,SAAS,EAAS,QAGpB,EAAQ,KACN,CAAA,QAAS,OACT,MAAO,EACP,EAAG,EACH,EAAG,EACH,UAAW,EAAS,GACpB,KAAM,EAAI,KACV,MAAO,EAAI,MACX,IAAK,EAAI,aASf,KAAC,OAAO,EAAQ,OAAO,SAAC,GAC5B,IAAA,EAAA,EAAA,EAAA,EACM,IADA,GAAc,EACd,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IACE,GAAY,cACT,EAAY,GAAK,EAAM,GAAM,EAAY,GAAK,EAAM,EAAvD,CACE,GAAc,EACd,aACA,MAER,gBAAiB,SAAC,GACpB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAQI,KAAU,EAAK,GAAK,IAAM,EAAK,IAAM,GAArC,CAIA,IAHA,EAAU,EACV,EAAU,EACV,EAAU,EACV,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAAA,CACE,GAAU,aAAK,EAAM,eAAiB,EAAM,cAA5C,OACgB,EAAM,KAAtB,GAAW,GACK,EAAM,KAAtB,GAAW,GACK,GAAO,IAAvB,GAAW,GACb,KAAU,GAAW,GAAgB,IAAX,GAAgB,GAAW,GAArD,CAOA,IAAA,EAAA,EAAA,GAJA,EAAuB,CACrB,CAAC,EAAK,GAAI,EAAI,MAAA,EAAA,IACd,CAAC,EAAK,GAAI,EAAI,MAAA,EAAA,MAEhB,OAAA,EAAA,EAAA,IACE,IADG,EAAG,GAAJ,EAAA,GACC,eAAiB,GAAA,GAAK,cAEvB,OAAG,OADH,EAAK,KAAC,eAAe,IAEZ,CACL,KAAM,EACN,MAAO,EAAG,MACV,IAAK,EAAG,UAMV,EAIN,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IAEE,IAFG,EAAG,GAAJ,EAAA,GAEC,OADH,EAAK,KAAC,eAAe,IAGnB,MAAO,CACL,KAFF,EAAI,KAAC,uBAAuB,GAG1B,MAAO,EAAG,MACV,IAAK,EAAG,QAGhB,eAAgB,SAAC,GACnB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAI,IAAA,EAAA,EAAA,GAAA,EAAA,CAAA,EAAA,EAAA,QAAA,YAAA,OAAA,EAAA,EAAA,IACE,IADG,EAAG,GAAJ,EAAA,GACC,GAAK,GAAA,GAAK,IAAO,GAAK,GAAA,GAAK,GAC5B,MAAO,CACL,IAAK,EACL,MAAO,IAGf,uBAAwB,SAAC,GACvB,OAAG,EAAO,GACR,EACM,EAAO,GAEb,EAAO,KAGP,EAAO,MAEb,OAAO,QAAU;;;AChmBjB,IAAA,uBAAA,oCAAA,gCAAA,iCAAA,iBAAA,oBAAA,EAAA,QAAA,EAAA,iBAAmB,QAAQ,sBAI3B,oBAAsB,SAAC,GACvB,IAAA,EAAA,EAAA,EAAA,EAAA,EACE,IAAA,KADA,EAAU,EACV,SACE,GAAW,qBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,qBAAA,YAAD,GAA8B,cAC3C,GAAW,iBAAC,IAAA,KAAA,EAAA,GAAA,cAAA,YAAD,GAAqB,QAGlC,uBAAyB,GACzB,oCAAsC,IACtC,iCAAmC,GACnC,gCAAkC,GAElC,QACE,CAAA,IAAK,SAAC,EAAG,GACX,IAAA,EAAA,EAAA,EAAA,EACI,GAAY,EAAI,EAAhB,OAAO,EACP,GAAiB,IAAL,EAAZ,OAAO,EAEP,IADA,EAAI,EACK,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,GAAK,EACL,GAAK,EACL,GAAK,SACP,GAEF,MAAO,SAAC,UAAM,KAAK,IAAI,GAAK,KAAK,IAAI,KACrC,KAAO,SAAC,UAAM,KAAK,IAAI,GAAK,KAAK,IAAI,IAErC,UAAW,SAAC,GACd,IAAA,EAAA,EAAA,EAAA,EACI,GAAY,EAAI,EAAhB,OAAO,EAEP,IADA,EAAI,EACY,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAhB,GAAK,SACL,GAmCF,8BAA+B,SAAC,EAAU,EAAS,GAAkB,GAEvE,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAII,IAJA,EAAI,EAAS,OAGb,EAAA,qBAAgB,IAAA,EAAA,GAAY,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,SAAZ,aAAhB,GACA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,IACE,WAAe,GAAG,KAAK,GAEzB,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,SACM,KAAK,SAAC,EAAI,UAAO,EAAG,EAAI,EAAG,IAwFjC,IAtFA,EAKE,CAAA,EAAA,qBAAK,IAAA,EAAA,GAAY,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,SAAZ,aAAL,GAIA,GAAA,qBAAK,IAAA,EAAA,GAAY,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,SAAZ,aAAL,GAGA,EAAA,qBAAK,IAAA,EAAA,GAAY,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,SAAZ,aAAL,IAIF,EAAS,EAAC,EAAG,KACjB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAcM,IAAA,KAdA,EAAI,EAAE,EACN,EAAK,KAAC,iBAAiB,EAAG,GACvB,EAAI,IAIL,GAAM,EAAQ,GAAG,EAAE,EAAI,GAAG,EAAI,IAEhC,EAAI,KAAC,UAAU,GAAK,EACb,IACL,GAAK,KAAK,IAAI,oCAAqC,EAAI,IAIzD,EAAA,EAAA,EAAA,GACE,YAAY,EAAc,IAChB,GAAe,EAAzB,cAEF,EAAQ,EAAE,GAAG,GAAK,EAClB,EAAQ,EAAE,GAAG,GAAK,EAClB,EAAQ,GAAG,GAAG,GAAK,IAGrB,EAAoB,CAAC,IACzB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAGM,IAFA,EAAI,EAAsB,EAAG,GAC7B,EAAO,EAAG,GACV,EAAA,GAAS,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAIP,EAAI,EAAsB,EAAG,6BAC7B,IAAA,KAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,UACE,EAAI,SAAS,GAKiB,eAAlB,EAAO,gBAEnB,EAAO,EAAG,EAAI,4BAGpB,EAAwB,EAAC,EAAG,KAC1B,CAAA,QAAS,aACT,MAAO,EAAQ,MAAA,GAAA,EAAA,GAAA,KACf,EAAG,EACH,EAAG,KAIL,EAAS,CAAC,IACd,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAKM,IAAA,KALA,EAAyB,GACzB,EAAI,EAAI,EAER,OAAI,EACJ,EAAI,SACJ,EAAA,EAAA,EAAA,YACmB,IACf,EAAI,EACJ,EAAI,GAER,KAAM,GAAK,GACT,EAAI,EAAQ,EAAE,GAAG,GACjB,EAAuB,QAAQ,GAC/B,EAAI,EAAE,EAAI,EACV,WACF,IAEO,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAT,CACE,IAAA,EAAA,EAAA,GAAA,EAAA,EAAA,IAAA,OAAA,EAAA,EAAA,IACE,YAAK,EAAI,EACP,IAAA,KAAA,EAAA,EAAA,EAAA,EAAA,GACE,EAAI,SAAS,GACb,EAAO,EAAG,EAAI,QAEhB,EAAO,EAAG,GACd,EAAkB,UAEpB,GADA,EAAyB,EAAO,IACG,OAIjC,EADoB,IAAnB,EAAS,OACA,EAEA,EAAQ,EAAE,EAAI,GAAG,GAG7B,CAAA,SAAU,EACV,QAAS,EACT,cAAe,KAAC,MAAM,GACtB,SAAU,IAMZ,iBAAkB,SAAC,EAAO,GAC5B,IAAA,EAAA,EAAI,OAAwB,MAAA,EAAA,QAAjB,EAAM,SACb,EAAc,EACX,EAAM,MAAM,OAAS,EAAS,SAC/B,EAAuC,IAAtB,EAAM,MAAM,OAC3B,iCAEA,iCASJ,EAPE,CAAA,WAAY,KAAC,mBACb,WAAY,KAAC,mBACb,QAAY,KAAC,gBACb,OAAY,KAAC,eACb,SAAY,KAAC,iBACb,MAAY,KAAC,cACb,KAAY,KAAC,cACgB,EAAM,SAAS,KAAK,KAAM,GACzD,EAAM,QAAU,KAAK,IAAI,EAAS,GAClC,EAAM,cAAgB,KAAC,MAAM,EAAM,SACnC,EAAM,UAER,mBAAoB,SAAC,GACvB,IAAA,EAAA,SAAI,EAAU,KAAK,IAAI,uBAAwB,EAAM,MAAM,WACzC,OAAO,oBACjB,EAAU,OAAO,WAGrB,EAAuC,IAAtB,EAAM,MAAM,OAC3B,iCAAmC,EAEnC,gCAAkC,EACpC,KAAK,IAAI,EAAS,IAEpB,eAAgB,SAAC,UACf,EAAM,aAAe,EAAM,cAE7B,iBAAkB,SAAC,GACrB,IAAA,EAAA,SAGM,EADe,OAFjB,EAAY,EAAM,MAAM,OAAO,KAET,MAAnB,GAAwB,MAAxB,GAA6B,MAA7B,GAAkC,MAAlC,GAAuC,MAAvC,GAA4C,MAA5C,EACc,EAEZ,EAAU,MAAM,MACF,GAIA,GACZ,EAAM,YAGX,GAAgB,GAClB,EAAe,EAAM,MAAM,QAE7B,eAAgB,GAChB,gBAAgB,IAAI,MAAO,cAE3B,cAAe,SAAC,GAClB,IAAA,EAAA,EAOI,GAPA,EACE,CAAA,YAAc,GACd,YAAc,GACd,MAAc,GACd,aAAc,GACd,OAAc,GACd,QAAc,IACb,EAAM,cAAc,SACrB,KAAK,IAAI,EAAiB,EAAM,YAAa,EAAM,MAAM,QACtD,OAAO,EAAM,YAAb,IACE,qBAGH,EAAa,KAAK,IAAI,SAAS,EAAM,YAAY,IAAM,KAAC,gBACxD,EAAa,KAAK,IAAI,EAAY,KAAC,kBAGzC,aAAc,SAAC,GACjB,IAAA,SAEI,EAAuB,IADV,KAAK,IAAI,KAAK,IAAI,EAAM,KAAO,KAAC,gBAAiB,KAAC,gBAG/C,EAAM,YAAtB,GAAW,GACX,GAEF,wBAAyB,oBAAoB,iBAAiB,QAE9D,sBAAuB,oBAAoB,iBAAiB,QAE5D,4BAA6B,mBAAC,IAAA,KAAA,EAAA,GAAA,EAAA,iBAAA,qBAAA,YAAD,GAAuC,OACpE,0BAA2B,mBAAC,IAAA,KAAA,EAAA,GAAA,EAAA,iBAAA,qBAAA,YAAD,GAAuC,OAElE,gBAAiB,SAAC,GACpB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAUI,IAVmB,YAAnB,EAAG,EAAM,QAAoB,WAA1B,GACD,EAAI,KAAC,4BACL,EAAI,KAAC,0BAEL,EAAI,KAAC,0BACL,EAAI,KAAC,uBACP,EAAU,EACV,EAAI,EAAM,MAAM,OAChB,EAAI,EAAM,MAED,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAEP,IAAS,EAAA,EAAA,EAAA,EADQ,KAAK,IAAI,EAAG,EAAI,GACxB,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EACP,GAAW,KAAC,IAAI,EAAI,EAAG,EAAI,GAAK,EAAI,KAAK,IAAI,EAAG,GAGpD,GAAG,EAAM,cAGP,GAFA,EAAI,EAAM,cACV,EAAI,EAAM,MAAM,OAAS,EAAM,cACvB,IAAL,GAAe,IAAL,EACX,GAAW,MADb,CAIE,IADA,EAAqB,EACyB,EAAA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAA9C,GAAsB,KAAC,IAAI,EAAI,EAAG,GAClC,GAAW,SACf,GAEF,mBAAoB,SAAC,GACvB,IAAA,SAAI,EAAM,aAAe,EAAM,KAC3B,EAAM,qBAAuB,KAAC,qBAAqB,GACnD,EAAM,gBAAkB,KAAC,gBAAgB,GACzC,EAAsB,EAAM,SAAa,EAAK,EAC9C,EAAM,aAAe,EAAM,qBAAuB,EAAM,gBAAkB,GAE5E,YAAa,iBACb,UAAW,iBACX,UAAW,YACX,UAAW,YAEX,qBAAsB,SAAC,GACzB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EACI,IADA,EAAO,EAAM,OACI,MAAM,KAAC,YAAc,EAAK,gBAAiB,EAA5D,OAAO,EAIP,IAAA,EAAA,EAAA,GAAA,EAAA,CAAA,KAAA,YAAA,KAAA,UAAA,KAAA,YAAA,OAAA,EAAA,EAAA,IACE,UAAY,EAAK,MAAM,GAAvB,OAAO,EAOT,IAHA,EAAI,uBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,MAAA,KAAA,OAAA,EAAA,EAAA,aAAuC,MAAM,iBAA7C,YAAD,GAAuD,OAC3D,EAAI,uBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,GAAA,EAAA,EAAA,MAAA,KAAA,OAAA,EAAA,EAAA,aAAuC,MAAM,iBAA7C,YAAD,GAAuD,OAC3D,EAAa,EACyB,EAAA,EAAA,EAAA,EAAA,KAAA,IAAA,EAAA,GAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAtC,GAAc,KAAC,IAAI,EAAI,EAAG,UAC1B,GAEF,gBAAiB,SAAC,GACpB,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAI,IAAgB,EAAM,KAAtB,OAAO,EAEP,IAAA,KADA,EAAa,EACb,EAAA,EAAA,IAKE,UAHA,EAAO,EAAM,MAAM,cAAc,MAAM,IACvC,EAAI,qBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,eAAgC,UAAhC,YAAD,GAAyC,OAC7C,EAAI,qBAAC,IAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,OAAA,EAAA,EAAA,eAAgC,UAAhC,YAAD,GAA2C,OACvC,IAAL,GAAe,IAAL,EAIX,GAAc,MAJhB,CAUE,IADA,EAAgB,EACyB,EAAA,EAAA,EAAA,EAFrC,KAAK,IAAI,EAAG,GAEyB,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAzC,GAAiB,KAAC,IAAI,EAAI,EAAG,GAC7B,GAAc,SAClB,IAIJ,OAAO,QAAU;;;AChXjB,IAAA,eAAA,eACE,CAAA,sBAAuB,SAAC,GAC1B,IAAA,EAAA,EAAA,EAAA,EAOI,IAAA,KADA,EAAsB,GANtB,EACE,CAAA,+BAAgC,GAAW,IAAM,MACjD,mCAAoC,EAAU,GAC9C,oCAAqC,EAAU,IAC/C,qCAAsC,EAAU,aAIhD,EAAoB,GAAY,KAAC,aAAa,SAEhD,CAAA,oBAAqB,EACrB,oBAAqB,EACrB,MAAO,KAAC,iBAAiB,KAG3B,iBAAkB,SAAC,GAEjB,OADQ,EACL,EAAU,KAEX,EACM,EAAU,IAJV,EAMN,EACM,EAAU,IAPV,EASN,EACM,EAAU,KAVV,EAaN,EAGA,GAEJ,aAAc,SAAC,GACjB,IAAA,EAAA,EAAA,SAAa,GACF,KACD,MACE,QACD,SACG,UACT,EAAa,GAAkB,EAAU,EACxC,CAAC,KAAM,sBACD,EARC,GAUP,CADA,EAAO,KAAK,MAAM,MACR,YACJ,EAVD,KAYL,CADA,EAAO,KAAK,MAAM,EAZX,OAaG,YACJ,EAZF,MAcJ,CADA,EAAO,KAAK,MAAM,EAdb,SAeK,UACJ,EAdA,QAgBN,CADA,EAAO,KAAK,MAAM,EAhBd,UAiBM,SACJ,EAhBD,SAkBL,CADA,EAAO,KAAK,MAAM,EAlBZ,YAmBI,WACJ,EAlBE,SAoBR,CADA,EAAO,KAAK,MAAM,EApBb,aAqBK,UAEV,CAAC,KAAM,aACa,MAAA,GAAgC,IAAf,IAAvC,GAAe,KACf,IAEJ,OAAO,QAAU",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",
    "# generated by scripts/build_keyboard_adjacency_graphs.py\nadjacency_graphs = \n  qwerty: {\"!\": [\"`~\", null, null, \"2@\", \"qQ\", null], \"\\\"\": [\";:\", \"[{\", \"]}\", null, null, \"/?\"], \"#\": [\"2@\", null, null, \"4$\", \"eE\", \"wW\"], \"$\": [\"3#\", null, null, \"5%\", \"rR\", \"eE\"], \"%\": [\"4$\", null, null, \"6^\", \"tT\", \"rR\"], \"&\": [\"6^\", null, null, \"8*\", \"uU\", \"yY\"], \"'\": [\";:\", \"[{\", \"]}\", null, null, \"/?\"], \"(\": [\"8*\", null, null, \"0)\", \"oO\", \"iI\"], \")\": [\"9(\", null, null, \"-_\", \"pP\", \"oO\"], \"*\": [\"7&\", null, null, \"9(\", \"iI\", \"uU\"], \"+\": [\"-_\", null, null, null, \"]}\", \"[{\"], \",\": [\"mM\", \"kK\", \"lL\", \".>\", null, null], \"-\": [\"0)\", null, null, \"=+\", \"[{\", \"pP\"], \".\": [\",<\", \"lL\", \";:\", \"/?\", null, null], \"/\": [\".>\", \";:\", \"'\\\"\", null, null, null], \"0\": [\"9(\", null, null, \"-_\", \"pP\", \"oO\"], \"1\": [\"`~\", null, null, \"2@\", \"qQ\", null], \"2\": [\"1!\", null, null, \"3#\", \"wW\", \"qQ\"], \"3\": [\"2@\", null, null, \"4$\", \"eE\", \"wW\"], \"4\": [\"3#\", null, null, \"5%\", \"rR\", \"eE\"], \"5\": [\"4$\", null, null, \"6^\", \"tT\", \"rR\"], \"6\": [\"5%\", null, null, \"7&\", \"yY\", \"tT\"], \"7\": [\"6^\", null, null, \"8*\", \"uU\", \"yY\"], \"8\": [\"7&\", null, null, \"9(\", \"iI\", \"uU\"], \"9\": [\"8*\", null, null, \"0)\", \"oO\", \"iI\"], \":\": [\"lL\", \"pP\", \"[{\", \"'\\\"\", \"/?\", \".>\"], \";\": [\"lL\", \"pP\", \"[{\", \"'\\\"\", \"/?\", \".>\"], \"<\": [\"mM\", \"kK\", \"lL\", \".>\", null, null], \"=\": [\"-_\", null, null, null, \"]}\", \"[{\"], \">\": [\",<\", \"lL\", \";:\", \"/?\", null, null], \"?\": [\".>\", \";:\", \"'\\\"\", null, null, null], \"@\": [\"1!\", null, null, \"3#\", \"wW\", \"qQ\"], \"A\": [null, \"qQ\", \"wW\", \"sS\", \"zZ\", null], \"B\": [\"vV\", \"gG\", \"hH\", \"nN\", null, null], \"C\": [\"xX\", \"dD\", \"fF\", \"vV\", null, null], \"D\": [\"sS\", \"eE\", \"rR\", \"fF\", \"cC\", \"xX\"], \"E\": [\"wW\", \"3#\", \"4$\", \"rR\", \"dD\", \"sS\"], \"F\": [\"dD\", \"rR\", \"tT\", \"gG\", \"vV\", \"cC\"], \"G\": [\"fF\", \"tT\", \"yY\", \"hH\", \"bB\", \"vV\"], \"H\": [\"gG\", \"yY\", \"uU\", \"jJ\", \"nN\", \"bB\"], \"I\": [\"uU\", \"8*\", \"9(\", \"oO\", \"kK\", \"jJ\"], \"J\": [\"hH\", \"uU\", \"iI\", \"kK\", \"mM\", \"nN\"], \"K\": [\"jJ\", \"iI\", \"oO\", \"lL\", \",<\", \"mM\"], \"L\": [\"kK\", \"oO\", \"pP\", \";:\", \".>\", \",<\"], \"M\": [\"nN\", \"jJ\", \"kK\", \",<\", null, null], \"N\": [\"bB\", \"hH\", \"jJ\", \"mM\", null, null], \"O\": [\"iI\", \"9(\", \"0)\", \"pP\", \"lL\", \"kK\"], \"P\": [\"oO\", \"0)\", \"-_\", \"[{\", \";:\", \"lL\"], \"Q\": [null, \"1!\", \"2@\", \"wW\", \"aA\", null], \"R\": [\"eE\", \"4$\", \"5%\", \"tT\", \"fF\", \"dD\"], \"S\": [\"aA\", \"wW\", \"eE\", \"dD\", \"xX\", \"zZ\"], \"T\": [\"rR\", \"5%\", \"6^\", \"yY\", \"gG\", \"fF\"], \"U\": [\"yY\", \"7&\", \"8*\", \"iI\", \"jJ\", \"hH\"], \"V\": [\"cC\", \"fF\", \"gG\", \"bB\", null, null], \"W\": [\"qQ\", \"2@\", \"3#\", \"eE\", \"sS\", \"aA\"], \"X\": [\"zZ\", \"sS\", \"dD\", \"cC\", null, null], \"Y\": [\"tT\", \"6^\", \"7&\", \"uU\", \"hH\", \"gG\"], \"Z\": [null, \"aA\", \"sS\", \"xX\", null, null], \"[\": [\"pP\", \"-_\", \"=+\", \"]}\", \"'\\\"\", \";:\"], \"\\\\\": [\"]}\", null, null, null, null, null], \"]\": [\"[{\", \"=+\", null, \"\\\\|\", null, \"'\\\"\"], \"^\": [\"5%\", null, null, \"7&\", \"yY\", \"tT\"], \"_\": [\"0)\", null, null, \"=+\", \"[{\", \"pP\"], \"`\": [null, null, null, \"1!\", null, null], \"a\": [null, \"qQ\", \"wW\", \"sS\", \"zZ\", null], \"b\": [\"vV\", \"gG\", \"hH\", \"nN\", null, null], \"c\": [\"xX\", \"dD\", \"fF\", \"vV\", null, null], \"d\": [\"sS\", \"eE\", \"rR\", \"fF\", \"cC\", \"xX\"], \"e\": [\"wW\", \"3#\", \"4$\", \"rR\", \"dD\", \"sS\"], \"f\": [\"dD\", \"rR\", \"tT\", \"gG\", \"vV\", \"cC\"], \"g\": [\"fF\", \"tT\", \"yY\", \"hH\", \"bB\", \"vV\"], \"h\": [\"gG\", \"yY\", \"uU\", \"jJ\", \"nN\", \"bB\"], \"i\": [\"uU\", \"8*\", \"9(\", \"oO\", \"kK\", \"jJ\"], \"j\": [\"hH\", \"uU\", \"iI\", \"kK\", \"mM\", \"nN\"], \"k\": [\"jJ\", \"iI\", \"oO\", \"lL\", \",<\", \"mM\"], \"l\": [\"kK\", \"oO\", \"pP\", \";:\", \".>\", \",<\"], \"m\": [\"nN\", \"jJ\", \"kK\", \",<\", null, null], \"n\": [\"bB\", \"hH\", \"jJ\", \"mM\", null, null], \"o\": [\"iI\", \"9(\", \"0)\", \"pP\", \"lL\", \"kK\"], \"p\": [\"oO\", \"0)\", \"-_\", \"[{\", \";:\", \"lL\"], \"q\": [null, \"1!\", \"2@\", \"wW\", \"aA\", null], \"r\": [\"eE\", \"4$\", \"5%\", \"tT\", \"fF\", \"dD\"], \"s\": [\"aA\", \"wW\", \"eE\", \"dD\", \"xX\", \"zZ\"], \"t\": [\"rR\", \"5%\", \"6^\", \"yY\", \"gG\", \"fF\"], \"u\": [\"yY\", \"7&\", \"8*\", \"iI\", \"jJ\", \"hH\"], \"v\": [\"cC\", \"fF\", \"gG\", \"bB\", null, null], \"w\": [\"qQ\", \"2@\", \"3#\", \"eE\", \"sS\", \"aA\"], \"x\": [\"zZ\", \"sS\", \"dD\", \"cC\", null, null], \"y\": [\"tT\", \"6^\", \"7&\", \"uU\", \"hH\", \"gG\"], \"z\": [null, \"aA\", \"sS\", \"xX\", null, null], \"{\": [\"pP\", \"-_\", \"=+\", \"]}\", \"'\\\"\", \";:\"], \"|\": [\"]}\", null, null, null, null, null], \"}\": [\"[{\", \"=+\", null, \"\\\\|\", null, \"'\\\"\"], \"~\": [null, null, null, \"1!\", null, null]}\n  dvorak: {\"!\": [\"`~\", null, null, \"2@\", \"'\\\"\", null], \"\\\"\": [null, \"1!\", \"2@\", \",<\", \"aA\", null], \"#\": [\"2@\", null, null, \"4$\", \".>\", \",<\"], \"$\": [\"3#\", null, null, \"5%\", \"pP\", \".>\"], \"%\": [\"4$\", null, null, \"6^\", \"yY\", \"pP\"], \"&\": [\"6^\", null, null, \"8*\", \"gG\", \"fF\"], \"'\": [null, \"1!\", \"2@\", \",<\", \"aA\", null], \"(\": [\"8*\", null, null, \"0)\", \"rR\", \"cC\"], \")\": [\"9(\", null, null, \"[{\", \"lL\", \"rR\"], \"*\": [\"7&\", null, null, \"9(\", \"cC\", \"gG\"], \"+\": [\"/?\", \"]}\", null, \"\\\\|\", null, \"-_\"], \",\": [\"'\\\"\", \"2@\", \"3#\", \".>\", \"oO\", \"aA\"], \"-\": [\"sS\", \"/?\", \"=+\", null, null, \"zZ\"], \".\": [\",<\", \"3#\", \"4$\", \"pP\", \"eE\", \"oO\"], \"/\": [\"lL\", \"[{\", \"]}\", \"=+\", \"-_\", \"sS\"], \"0\": [\"9(\", null, null, \"[{\", \"lL\", \"rR\"], \"1\": [\"`~\", null, null, \"2@\", \"'\\\"\", null], \"2\": [\"1!\", null, null, \"3#\", \",<\", \"'\\\"\"], \"3\": [\"2@\", null, null, \"4$\", \".>\", \",<\"], \"4\": [\"3#\", null, null, \"5%\", \"pP\", \".>\"], \"5\": [\"4$\", null, null, \"6^\", \"yY\", \"pP\"], \"6\": [\"5%\", null, null, \"7&\", \"fF\", \"yY\"], \"7\": [\"6^\", null, null, \"8*\", \"gG\", \"fF\"], \"8\": [\"7&\", null, null, \"9(\", \"cC\", \"gG\"], \"9\": [\"8*\", null, null, \"0)\", \"rR\", \"cC\"], \":\": [null, \"aA\", \"oO\", \"qQ\", null, null], \";\": [null, \"aA\", \"oO\", \"qQ\", null, null], \"<\": [\"'\\\"\", \"2@\", \"3#\", \".>\", \"oO\", \"aA\"], \"=\": [\"/?\", \"]}\", null, \"\\\\|\", null, \"-_\"], \">\": [\",<\", \"3#\", \"4$\", \"pP\", \"eE\", \"oO\"], \"?\": [\"lL\", \"[{\", \"]}\", \"=+\", \"-_\", \"sS\"], \"@\": [\"1!\", null, null, \"3#\", \",<\", \"'\\\"\"], \"A\": [null, \"'\\\"\", \",<\", \"oO\", \";:\", null], \"B\": [\"xX\", \"dD\", \"hH\", \"mM\", null, null], \"C\": [\"gG\", \"8*\", \"9(\", \"rR\", \"tT\", \"hH\"], \"D\": [\"iI\", \"fF\", \"gG\", \"hH\", \"bB\", \"xX\"], \"E\": [\"oO\", \".>\", \"pP\", \"uU\", \"jJ\", \"qQ\"], \"F\": [\"yY\", \"6^\", \"7&\", \"gG\", \"dD\", \"iI\"], \"G\": [\"fF\", \"7&\", \"8*\", \"cC\", \"hH\", \"dD\"], \"H\": [\"dD\", \"gG\", \"cC\", \"tT\", \"mM\", \"bB\"], \"I\": [\"uU\", \"yY\", \"fF\", \"dD\", \"xX\", \"kK\"], \"J\": [\"qQ\", \"eE\", \"uU\", \"kK\", null, null], \"K\": [\"jJ\", \"uU\", \"iI\", \"xX\", null, null], \"L\": [\"rR\", \"0)\", \"[{\", \"/?\", \"sS\", \"nN\"], \"M\": [\"bB\", \"hH\", \"tT\", \"wW\", null, null], \"N\": [\"tT\", \"rR\", \"lL\", \"sS\", \"vV\", \"wW\"], \"O\": [\"aA\", \",<\", \".>\", \"eE\", \"qQ\", \";:\"], \"P\": [\".>\", \"4$\", \"5%\", \"yY\", \"uU\", \"eE\"], \"Q\": [\";:\", \"oO\", \"eE\", \"jJ\", null, null], \"R\": [\"cC\", \"9(\", \"0)\", \"lL\", \"nN\", \"tT\"], \"S\": [\"nN\", \"lL\", \"/?\", \"-_\", \"zZ\", \"vV\"], \"T\": [\"hH\", \"cC\", \"rR\", \"nN\", \"wW\", \"mM\"], \"U\": [\"eE\", \"pP\", \"yY\", \"iI\", \"kK\", \"jJ\"], \"V\": [\"wW\", \"nN\", \"sS\", \"zZ\", null, null], \"W\": [\"mM\", \"tT\", \"nN\", \"vV\", null, null], \"X\": [\"kK\", \"iI\", \"dD\", \"bB\", null, null], \"Y\": [\"pP\", \"5%\", \"6^\", \"fF\", \"iI\", \"uU\"], \"Z\": [\"vV\", \"sS\", \"-_\", null, null, null], \"[\": [\"0)\", null, null, \"]}\", \"/?\", \"lL\"], \"\\\\\": [\"=+\", null, null, null, null, null], \"]\": [\"[{\", null, null, null, \"=+\", \"/?\"], \"^\": [\"5%\", null, null, \"7&\", \"fF\", \"yY\"], \"_\": [\"sS\", \"/?\", \"=+\", null, null, \"zZ\"], \"`\": [null, null, null, \"1!\", null, null], \"a\": [null, \"'\\\"\", \",<\", \"oO\", \";:\", null], \"b\": [\"xX\", \"dD\", \"hH\", \"mM\", null, null], \"c\": [\"gG\", \"8*\", \"9(\", \"rR\", \"tT\", \"hH\"], \"d\": [\"iI\", \"fF\", \"gG\", \"hH\", \"bB\", \"xX\"], \"e\": [\"oO\", \".>\", \"pP\", \"uU\", \"jJ\", \"qQ\"], \"f\": [\"yY\", \"6^\", \"7&\", \"gG\", \"dD\", \"iI\"], \"g\": [\"fF\", \"7&\", \"8*\", \"cC\", \"hH\", \"dD\"], \"h\": [\"dD\", \"gG\", \"cC\", \"tT\", \"mM\", \"bB\"], \"i\": [\"uU\", \"yY\", \"fF\", \"dD\", \"xX\", \"kK\"], \"j\": [\"qQ\", \"eE\", \"uU\", \"kK\", null, null], \"k\": [\"jJ\", \"uU\", \"iI\", \"xX\", null, null], \"l\": [\"rR\", \"0)\", \"[{\", \"/?\", \"sS\", \"nN\"], \"m\": [\"bB\", \"hH\", \"tT\", \"wW\", null, null], \"n\": [\"tT\", \"rR\", \"lL\", \"sS\", \"vV\", \"wW\"], \"o\": [\"aA\", \",<\", \".>\", \"eE\", \"qQ\", \";:\"], \"p\": [\".>\", \"4$\", \"5%\", \"yY\", \"uU\", \"eE\"], \"q\": [\";:\", \"oO\", \"eE\", \"jJ\", null, null], \"r\": [\"cC\", \"9(\", \"0)\", \"lL\", \"nN\", \"tT\"], \"s\": [\"nN\", \"lL\", \"/?\", \"-_\", \"zZ\", \"vV\"], \"t\": [\"hH\", \"cC\", \"rR\", \"nN\", \"wW\", \"mM\"], \"u\": [\"eE\", \"pP\", \"yY\", \"iI\", \"kK\", \"jJ\"], \"v\": [\"wW\", \"nN\", \"sS\", \"zZ\", null, null], \"w\": [\"mM\", \"tT\", \"nN\", \"vV\", null, null], \"x\": [\"kK\", \"iI\", \"dD\", \"bB\", null, null], \"y\": [\"pP\", \"5%\", \"6^\", \"fF\", \"iI\", \"uU\"], \"z\": [\"vV\", \"sS\", \"-_\", null, null, null], \"{\": [\"0)\", null, null, \"]}\", \"/?\", \"lL\"], \"|\": [\"=+\", null, null, null, null, null], \"}\": [\"[{\", null, null, null, \"=+\", \"/?\"], \"~\": [null, null, null, \"1!\", null, null]}\n  keypad: {\"*\": [\"/\", null, null, null, \"-\", \"+\", \"9\", \"8\"], \"+\": [\"9\", \"*\", \"-\", null, null, null, null, \"6\"], \"-\": [\"*\", null, null, null, null, null, \"+\", \"9\"], \".\": [\"0\", \"2\", \"3\", null, null, null, null, null], \"/\": [null, null, null, null, \"*\", \"9\", \"8\", \"7\"], \"0\": [null, \"1\", \"2\", \"3\", \".\", null, null, null], \"1\": [null, null, \"4\", \"5\", \"2\", \"0\", null, null], \"2\": [\"1\", \"4\", \"5\", \"6\", \"3\", \".\", \"0\", null], \"3\": [\"2\", \"5\", \"6\", null, null, null, \".\", \"0\"], \"4\": [null, null, \"7\", \"8\", \"5\", \"2\", \"1\", null], \"5\": [\"4\", \"7\", \"8\", \"9\", \"6\", \"3\", \"2\", \"1\"], \"6\": [\"5\", \"8\", \"9\", \"+\", null, null, \"3\", \"2\"], \"7\": [null, null, null, \"/\", \"8\", \"5\", \"4\", null], \"8\": [\"7\", null, \"/\", \"*\", \"9\", \"6\", \"5\", \"4\"], \"9\": [\"8\", \"/\", \"*\", \"-\", \"+\", null, \"6\", \"5\"]}\n  mac_keypad: {\"*\": [\"/\", null, null, null, null, null, \"-\", \"9\"], \"+\": [\"6\", \"9\", \"-\", null, null, null, null, \"3\"], \"-\": [\"9\", \"/\", \"*\", null, null, null, \"+\", \"6\"], \".\": [\"0\", \"2\", \"3\", null, null, null, null, null], \"/\": [\"=\", null, null, null, \"*\", \"-\", \"9\", \"8\"], \"0\": [null, \"1\", \"2\", \"3\", \".\", null, null, null], \"1\": [null, null, \"4\", \"5\", \"2\", \"0\", null, null], \"2\": [\"1\", \"4\", \"5\", \"6\", \"3\", \".\", \"0\", null], \"3\": [\"2\", \"5\", \"6\", \"+\", null, null, \".\", \"0\"], \"4\": [null, null, \"7\", \"8\", \"5\", \"2\", \"1\", null], \"5\": [\"4\", \"7\", \"8\", \"9\", \"6\", \"3\", \"2\", \"1\"], \"6\": [\"5\", \"8\", \"9\", \"-\", \"+\", null, \"3\", \"2\"], \"7\": [null, null, null, \"=\", \"8\", \"5\", \"4\", null], \"8\": [\"7\", null, \"=\", \"/\", \"9\", \"6\", \"5\", \"4\"], \"9\": [\"8\", \"=\", \"/\", \"*\", \"-\", \"+\", \"6\", \"5\"], \"=\": [null, null, null, null, \"/\", \"9\", \"8\", \"7\"]}\n\nmodule.exports = adjacency_graphs\n",
    "scoring = require('./scoring')\n\nfeedback =\n  default_feedback:\n    warning: ''\n    suggestions: [\n      \"Use a few words, avoid common phrases\"\n      \"No need for symbols, digits, or uppercase letters\"\n    ]\n\n  get_feedback: (score, sequence) ->\n    # starting feedback\n    return @default_feedback if sequence.length == 0\n\n    # no feedback if score is good or great.\n    return if score > 2\n      warning: ''\n      suggestions: []\n\n    # tie feedback to the longest match for longer sequences\n    longest_match = sequence[0]\n    for match in sequence[1..]\n      longest_match = match if match.token.length > longest_match.token.length\n    feedback = @get_match_feedback(longest_match, sequence.length == 1)\n    extra_feedback = 'Add another word or two. Uncommon words are better.'\n    if feedback?\n      feedback.suggestions.unshift extra_feedback\n      feedback.warning = '' unless feedback.warning?\n    else\n      feedback =\n        warning: ''\n        suggestions: [extra_feedback]\n    feedback\n\n  get_match_feedback: (match, is_sole_match) ->\n    switch match.pattern\n      when 'dictionary'\n        @get_dictionary_match_feedback match, is_sole_match\n\n      when 'spatial'\n        layout = match.graph.toUpperCase()\n        warning = if match.turns == 1\n          'Straight rows of keys are easy to guess'\n        else\n          'Short keyboard patterns are easy to guess'\n        warning: warning\n        suggestions: [\n          'Use a longer keyboard pattern with more turns'\n        ]\n\n      when 'repeat'\n        warning = if match.base_token.length == 1\n          'Repeats like \"aaa\" are easy to guess'\n        else\n          'Repeats like \"abcabcabc\" are only slightly harder to guess than \"abc\"'\n        warning: warning\n        suggestions: [\n          'Avoid repeated words and characters'\n        ]\n\n      when 'sequence'\n        warning: \"Sequences like abc or 6543 are easy to guess\"\n        suggestions: [\n          'Avoid sequences'\n        ]\n\n      when 'regex'\n        if match.regex_name == 'recent_year'\n          warning: \"Recent years are easy to guess\"\n          suggestions: [\n            'Avoid recent years'\n            'Avoid years that are associated with you'\n          ]\n\n      when 'date'\n        warning: \"Dates are often easy to guess\"\n        suggestions: [\n          'Avoid dates and years that are associated with you'\n        ]\n\n  get_dictionary_match_feedback: (match, is_sole_match) ->\n    warning = if match.dictionary_name == 'passwords'\n      if is_sole_match and not match.l33t and not match.reversed\n        if match.rank <= 10\n          'This is a top-10 common password'\n        else if match.rank <= 100\n          'This is a top-100 common password'\n        else\n          'This is a very common password'\n      else if match.guesses_log10 <= 4\n        'This is similar to a commonly used password'\n    else if match.dictionary_name == 'english_wikipedia'\n      if is_sole_match\n        'A word by itself is easy to guess'\n    else if match.dictionary_name in ['surnames', 'male_names', 'female_names']\n      if is_sole_match\n        'Names and surnames by themselves are easy to guess'\n      else\n        'Common names and surnames are easy to guess'\n    else\n      ''\n\n    suggestions = []\n    word = match.token\n    if word.match(scoring.START_UPPER)\n      suggestions.push \"Capitalization doesn't help very much\"\n    else if word.match(scoring.ALL_UPPER) and word.toLowerCase() != word\n      suggestions.push \"All-uppercase is almost as easy to guess as all-lowercase\"\n\n    if match.reversed and match.token.length >= 4\n      suggestions.push \"Reversed words aren't much harder to guess\"\n    if match.l33t\n      suggestions.push \"Predictable substitutions like '@' instead of 'a' don't help very much\"\n\n    result =\n      warning: warning\n      suggestions: suggestions\n    result\n\nmodule.exports = feedback\n",
    "# generated by build_frequency_lists.py\nfrequency_lists = \n  passwords: []\n  english_wikipedia: []\n  female_names: []\n  surnames: []\n  us_tv_and_film: []\n  male_names: []\nmodule.exports = frequency_lists\n",
    "matching = require './matching'\nscoring = require './scoring'\ntime_estimates = require './time_estimates'\nfeedback = require './feedback'\n\ntime = -> (new Date()).getTime()\n\nzxcvbn = (password, user_inputs = []) ->\n  start = time()\n  # reset the user inputs matcher on a per-request basis to keep things stateless\n  sanitized_inputs = []\n  for arg in user_inputs\n    if typeof arg in [\"string\", \"number\", \"boolean\"]\n      sanitized_inputs.push arg.toString().toLowerCase()\n  matching.set_user_input_dictionary sanitized_inputs\n  matches = matching.omnimatch password\n  result = scoring.most_guessable_match_sequence password, matches\n  result.calc_time = time() - start\n  attack_times = time_estimates.estimate_attack_times result.guesses\n  for prop, val of attack_times\n    result[prop] = val\n  result.feedback = feedback.get_feedback result.score, result.sequence\n  result\n\nmodule.exports = zxcvbn\n",
    "frequency_lists = require('./frequency_lists')\nadjacency_graphs = require('./adjacency_graphs')\nscoring = require('./scoring')\n\nbuild_ranked_dict = (ordered_list) ->\n  result = {}\n  i = 1 # rank starts at 1, not 0\n  for word in ordered_list\n    result[word] = i\n    i += 1\n  result\n\nRANKED_DICTIONARIES = {}\nfor name, lst of frequency_lists\n  RANKED_DICTIONARIES[name] = build_ranked_dict lst\n\nGRAPHS =\n  qwerty:     adjacency_graphs.qwerty\n  dvorak:     adjacency_graphs.dvorak\n  keypad:     adjacency_graphs.keypad\n  mac_keypad: adjacency_graphs.mac_keypad\n\nL33T_TABLE =\n  a: ['4', '@']\n  b: ['8']\n  c: ['(', '{', '[', '<']\n  e: ['3']\n  g: ['6', '9']\n  i: ['1', '!', '|']\n  l: ['1', '|', '7']\n  o: ['0']\n  s: ['$', '5']\n  t: ['+', '7']\n  x: ['%']\n  z: ['2']\n\nREGEXEN =\n  recent_year:  /19\\d\\d|200\\d|201\\d/g\n\nDATE_MAX_YEAR = 2050\nDATE_MIN_YEAR = 1000\nDATE_SPLITS =\n  4:[      # for length-4 strings, eg 1191 or 9111, two ways to split:\n    [1, 2] # 1 1 91 (2nd split starts at index 1, 3rd at index 2)\n    [2, 3] # 91 1 1\n    ]\n  5:[\n    [1, 3] # 1 11 91\n    [2, 3] # 11 1 91\n    ]\n  6:[\n    [1, 2] # 1 1 1991\n    [2, 4] # 11 11 91\n    [4, 5] # 1991 1 1\n    ]\n  7:[\n    [1, 3] # 1 11 1991\n    [2, 3] # 11 1 1991\n    [4, 5] # 1991 1 11\n    [4, 6] # 1991 11 1\n    ]\n  8:[\n    [2, 4] # 11 11 1991\n    [4, 6] # 1991 11 11\n    ]\n\nmatching =\n  empty: (obj) -> (k for k of obj).length == 0\n  extend: (lst, lst2) -> lst.push.apply lst, lst2\n  translate: (string, chr_map) -> (chr_map[chr] or chr for chr in string.split('')).join('')\n  mod: (n, m) -> ((n % m) + m) % m # mod impl that works for negative numbers\n  sorted: (matches) ->\n    # sort on i primary, j secondary\n    matches.sort (m1, m2) ->\n      (m1.i - m2.i) or (m1.j - m2.j)\n\n  # ------------------------------------------------------------------------------\n  # omnimatch -- combine everything ----------------------------------------------\n  # ------------------------------------------------------------------------------\n\n  omnimatch: (password) ->\n    matches = []\n    matchers = [\n      @dictionary_match\n      @reverse_dictionary_match\n      @l33t_match\n      @spatial_match\n      @repeat_match\n      @sequence_match\n      @regex_match\n      @date_match\n    ]\n    for matcher in matchers\n      @extend matches, matcher.call(this, password)\n    @sorted matches\n\n  #-------------------------------------------------------------------------------\n  # dictionary match (common passwords, english, last names, etc) ----------------\n  #-------------------------------------------------------------------------------\n\n  dictionary_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES) ->\n    # _ranked_dictionaries variable is for unit testing purposes\n    matches = []\n    len = password.length\n    password_lower = password.toLowerCase()\n    for dictionary_name, ranked_dict of _ranked_dictionaries\n      for i in [0...len]\n        for j in [i...len]\n          if password_lower[i..j] of ranked_dict\n            word = password_lower[i..j]\n            rank = ranked_dict[word]\n            matches.push\n              pattern: 'dictionary'\n              i: i\n              j: j\n              token: password[i..j]\n              matched_word: word\n              rank: rank\n              dictionary_name: dictionary_name\n              reversed: false\n              l33t: false\n    @sorted matches\n\n  reverse_dictionary_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES) ->\n    reversed_password = password.split('').reverse().join('')\n    matches = @dictionary_match reversed_password, _ranked_dictionaries\n    for match in matches\n      match.token = match.token.split('').reverse().join('') # reverse back\n      match.reversed = true\n      # map coordinates back to original string\n      [match.i, match.j] = [\n        password.length - 1 - match.j\n        password.length - 1 - match.i\n      ]\n    @sorted matches\n\n  set_user_input_dictionary: (ordered_list) ->\n    RANKED_DICTIONARIES['user_inputs'] = build_ranked_dict ordered_list.slice()\n\n  #-------------------------------------------------------------------------------\n  # dictionary match with common l33t substitutions ------------------------------\n  #-------------------------------------------------------------------------------\n\n  # makes a pruned copy of l33t_table that only includes password's possible substitutions\n  relevant_l33t_subtable: (password, table) ->\n    password_chars = {}\n    for chr in password.split('')\n      password_chars[chr] = true\n    subtable = {}\n    for letter, subs of table\n      relevant_subs = (sub for sub in subs when sub of password_chars)\n      if relevant_subs.length > 0\n        subtable[letter] = relevant_subs\n    subtable\n\n  # returns the list of possible 1337 replacement dictionaries for a given password\n  enumerate_l33t_subs: (table) ->\n    keys = (k for k of table)\n    subs = [[]]\n\n    dedup = (subs) ->\n      deduped = []\n      members = {}\n      for sub in subs\n        assoc = ([k,v] for k,v in sub)\n        assoc.sort()\n        label = (k+','+v for k,v in assoc).join('-')\n        unless label of members\n          members[label] = true\n          deduped.push sub\n      deduped\n\n    helper = (keys) ->\n      return if not keys.length\n      first_key = keys[0]\n      rest_keys = keys[1..]\n      next_subs = []\n      for l33t_chr in table[first_key]\n        for sub in subs\n          dup_l33t_index = -1\n          for i in [0...sub.length]\n            if sub[i][0] == l33t_chr\n              dup_l33t_index = i\n              break\n          if dup_l33t_index == -1\n            sub_extension = sub.concat [[l33t_chr, first_key]]\n            next_subs.push sub_extension\n          else\n            sub_alternative = sub.slice(0)\n            sub_alternative.splice(dup_l33t_index, 1)\n            sub_alternative.push [l33t_chr, first_key]\n            next_subs.push sub\n            next_subs.push sub_alternative\n      subs = dedup next_subs\n      helper(rest_keys)\n\n    helper(keys)\n    sub_dicts = [] # convert from assoc lists to dicts\n    for sub in subs\n      sub_dict = {}\n      for [l33t_chr, chr] in sub\n        sub_dict[l33t_chr] = chr\n      sub_dicts.push sub_dict\n    sub_dicts\n\n  l33t_match: (password, _ranked_dictionaries = RANKED_DICTIONARIES, _l33t_table = L33T_TABLE) ->\n    matches = []\n    for sub in @enumerate_l33t_subs @relevant_l33t_subtable(password, _l33t_table)\n      break if @empty sub # corner case: password has no relevant subs.\n      subbed_password = @translate password, sub\n      for match in @dictionary_match(subbed_password, _ranked_dictionaries)\n        token = password[match.i..match.j]\n        if token.toLowerCase() == match.matched_word\n          continue # only return the matches that contain an actual substitution\n        match_sub = {} # subset of mappings in sub that are in use for this match\n        for subbed_chr, chr of sub when token.indexOf(subbed_chr) != -1\n          match_sub[subbed_chr] = chr\n        match.l33t = true\n        match.token = token\n        match.sub = match_sub\n        match.sub_display = (\"#{k} -> #{v}\" for k,v of match_sub).join(', ')\n        matches.push match\n    @sorted matches.filter (match) ->\n      # filter single-character l33t matches to reduce noise.\n      # otherwise '1' matches 'i', '4' matches 'a', both very common English words\n      # with low dictionary rank.\n      match.token.length > 1\n\n  # ------------------------------------------------------------------------------\n  # spatial match (qwerty/dvorak/keypad) -----------------------------------------\n  # ------------------------------------------------------------------------------\n\n  spatial_match: (password, _graphs = GRAPHS) ->\n    matches = []\n    for graph_name, graph of _graphs\n      @extend matches, @spatial_match_helper(password, graph, graph_name)\n    @sorted matches\n\n  SHIFTED_RX: /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/\n  spatial_match_helper: (password, graph, graph_name) ->\n    matches = []\n    i = 0\n    while i < password.length - 1\n      j = i + 1\n      last_direction = null\n      turns = 0\n      if graph_name in ['qwerty', 'dvorak'] and @SHIFTED_RX.exec(password.charAt(i))\n        # initial character is shifted\n        shifted_count = 1\n      else\n        shifted_count = 0\n      loop\n        prev_char = password.charAt(j-1)\n        found = false\n        found_direction = -1\n        cur_direction = -1\n        adjacents = graph[prev_char] or []\n        # consider growing pattern by one character if j hasn't gone over the edge.\n        if j < password.length\n          cur_char = password.charAt(j)\n          for adj in adjacents\n            cur_direction += 1\n            if adj and adj.indexOf(cur_char) != -1\n              found = true\n              found_direction = cur_direction\n              if adj.indexOf(cur_char) == 1\n                # index 1 in the adjacency means the key is shifted,\n                # 0 means unshifted: A vs a, % vs 5, etc.\n                # for example, 'q' is adjacent to the entry '2@'.\n                # @ is shifted w/ index 1, 2 is unshifted.\n                shifted_count += 1\n              if last_direction != found_direction\n                # adding a turn is correct even in the initial case when last_direction is null:\n                # every spatial pattern starts with a turn.\n                turns += 1\n                last_direction = found_direction\n              break\n        # if the current pattern continued, extend j and try to grow again\n        if found\n          j += 1\n        # otherwise push the pattern discovered so far, if any...\n        else\n          if j - i > 2 # don't consider length 1 or 2 chains.\n            matches.push\n              pattern: 'spatial'\n              i: i\n              j: j-1\n              token: password[i...j]\n              graph: graph_name\n              turns: turns\n              shifted_count: shifted_count\n          # ...and then start a new search for the rest of the password.\n          i = j\n          break\n    matches\n\n  #-------------------------------------------------------------------------------\n  # repeats (aaa, abcabcabc) and sequences (abcdef) ------------------------------\n  #-------------------------------------------------------------------------------\n\n  repeat_match: (password) ->\n    matches = []\n    greedy = /(.+)\\1+/g\n    lazy = /(.+?)\\1+/g\n    lazy_anchored = /^(.+?)\\1+$/\n    lastIndex = 0\n    while lastIndex < password.length\n      greedy.lastIndex = lazy.lastIndex = lastIndex\n      greedy_match = greedy.exec password\n      lazy_match = lazy.exec password\n      break unless greedy_match?\n      if greedy_match[0].length > lazy_match[0].length\n        # greedy beats lazy for 'aabaab'\n        #   greedy: [aabaab, aab]\n        #   lazy:   [aa,     a]\n        match = greedy_match\n        # greedy's repeated string might itself be repeated, eg.\n        # aabaab in aabaabaabaab.\n        # run an anchored lazy match on greedy's repeated string\n        # to find the shortest repeated string\n        base_token = lazy_anchored.exec(match[0])[1]\n      else\n        # lazy beats greedy for 'aaaaa'\n        #   greedy: [aaaa,  aa]\n        #   lazy:   [aaaaa, a]\n        match = lazy_match\n        base_token = match[1]\n      [i, j] = [match.index, match.index + match[0].length - 1]\n      # recursively match and score the base string\n      base_analysis = scoring.most_guessable_match_sequence(\n        base_token\n        @omnimatch base_token\n      )\n      base_matches = base_analysis.sequence\n      base_guesses = base_analysis.guesses\n      matches.push\n        pattern: 'repeat'\n        i: i\n        j: j\n        token: match[0]\n        base_token: base_token\n        base_guesses: base_guesses\n        base_matches: base_matches\n        repeat_count: match[0].length / base_token.length\n      lastIndex = j + 1\n    matches\n\n  MAX_DELTA: 5\n  sequence_match: (password) ->\n    # Identifies sequences by looking for repeated differences in unicode codepoint.\n    # this allows skipping, such as 9753, and also matches some extended unicode sequences\n    # such as Greek and Cyrillic alphabets.\n    #\n    # for example, consider the input 'abcdb975zy'\n    #\n    # password: a   b   c   d   b    9   7   5   z   y\n    # index:    0   1   2   3   4    5   6   7   8   9\n    # delta:      1   1   1  -2  -41  -2  -2  69   1\n    #\n    # expected result:\n    # [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n\n    return [] if password.length == 1\n\n    update = (i, j, delta) =>\n      if j - i > 1 or Math.abs(delta) == 1\n        if 0 < Math.abs(delta) <= @MAX_DELTA\n          token = password[i..j]\n          if /^[a-z]+$/.test(token)\n            sequence_name = 'lower'\n            sequence_space = 26\n          else if /^[A-Z]+$/.test(token)\n            sequence_name = 'upper'\n            sequence_space = 26\n          else if /^\\d+$/.test(token)\n            sequence_name = 'digits'\n            sequence_space = 10\n          else\n            # conservatively stick with roman alphabet size.\n            # (this could be improved)\n            sequence_name = 'unicode'\n            sequence_space = 26\n          result.push\n            pattern: 'sequence'\n            i: i\n            j: j\n            token: password[i..j]\n            sequence_name: sequence_name\n            sequence_space: sequence_space\n            ascending: delta > 0\n\n    result = []\n    i = 0\n    last_delta = null\n\n    for k in [1...password.length]\n      delta = password.charCodeAt(k) - password.charCodeAt(k - 1)\n      unless last_delta?\n        last_delta = delta\n      continue if delta == last_delta\n      j = k - 1\n      update(i, j, last_delta)\n      i = j\n      last_delta = delta\n    update(i, password.length - 1, last_delta)\n    result\n\n  #-------------------------------------------------------------------------------\n  # regex matching ---------------------------------------------------------------\n  #-------------------------------------------------------------------------------\n\n  regex_match: (password, _regexen = REGEXEN) ->\n    matches = []\n    for name, regex of _regexen\n      regex.lastIndex = 0 # keeps regex_match stateless\n      while rx_match = regex.exec password\n        token = rx_match[0]\n        matches.push\n          pattern: 'regex'\n          token: token\n          i: rx_match.index\n          j: rx_match.index + rx_match[0].length - 1\n          regex_name: name\n          regex_match: rx_match\n    @sorted matches\n\n  #-------------------------------------------------------------------------------\n  # date matching ----------------------------------------------------------------\n  #-------------------------------------------------------------------------------\n\n  date_match: (password) ->\n    # a \"date\" is recognized as:\n    #   any 3-tuple that starts or ends with a 2- or 4-digit year,\n    #   with 2 or 0 separator chars (1.1.91 or 1191),\n    #   maybe zero-padded (01-01-91 vs 1-1-91),\n    #   a month between 1 and 12,\n    #   a day between 1 and 31.\n    #\n    # note: this isn't true date parsing in that \"feb 31st\" is allowed,\n    # this doesn't check for leap years, etc.\n    #\n    # recipe:\n    # start with regex to find maybe-dates, then attempt to map the integers\n    # onto month-day-year to filter the maybe-dates into dates.\n    # finally, remove matches that are substrings of other matches to reduce noise.\n    #\n    # note: instead of using a lazy or greedy regex to find many dates over the full string,\n    # this uses a ^...$ regex against every substring of the password -- less performant but leads\n    # to every possible date match.\n    matches = []\n    maybe_date_no_separator = /^\\d{4,8}$/\n    maybe_date_with_separator = ///\n      ^\n      ( \\d{1,4} )    # day, month, year\n      ( [\\s/\\\\_.-] ) # separator\n      ( \\d{1,2} )    # day, month\n      \\2             # same separator\n      ( \\d{1,4} )    # day, month, year\n      $\n    ///\n\n    # dates without separators are between length 4 '1191' and 8 '11111991'\n    for i in [0..password.length - 4]\n      for j in [i + 3..i + 7]\n        break if j >= password.length\n        token = password[i..j]\n        continue unless maybe_date_no_separator.exec token\n        candidates = []\n        for [k,l] in DATE_SPLITS[token.length]\n          dmy = @map_ints_to_dmy [\n            parseInt token[0...k]\n            parseInt token[k...l]\n            parseInt token[l...]\n          ]\n          candidates.push dmy if dmy?\n        continue unless candidates.length > 0\n        # at this point: different possible dmy mappings for the same i,j substring.\n        # match the candidate date that likely takes the fewest guesses: a year closest to 2000.\n        # (scoring.REFERENCE_YEAR).\n        #\n        # ie, considering '111504', prefer 11-15-04 to 1-1-1504\n        # (interpreting '04' as 2004)\n        best_candidate = candidates[0]\n        metric = (candidate) -> Math.abs candidate.year - scoring.REFERENCE_YEAR\n        min_distance = metric candidates[0]\n        for candidate in candidates[1..]\n          distance = metric candidate\n          if distance < min_distance\n            [best_candidate, min_distance] = [candidate, distance]\n        matches.push\n          pattern: 'date'\n          token: token\n          i: i\n          j: j\n          separator: ''\n          year: best_candidate.year\n          month: best_candidate.month\n          day: best_candidate.day\n\n    # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n    for i in [0..password.length - 6]\n      for j in [i + 5..i + 9]\n        break if j >= password.length\n        token = password[i..j]\n        rx_match = maybe_date_with_separator.exec token\n        continue unless rx_match?\n        dmy = @map_ints_to_dmy [\n          parseInt rx_match[1]\n          parseInt rx_match[3]\n          parseInt rx_match[4]\n        ]\n        continue unless dmy?\n        matches.push\n          pattern: 'date'\n          token: token\n          i: i\n          j: j\n          separator: rx_match[2]\n          year: dmy.year\n          month: dmy.month\n          day: dmy.day\n\n    # matches now contains all valid date strings in a way that is tricky to capture\n    # with regexes only. while thorough, it will contain some unintuitive noise:\n    #\n    # '2015_06_04', in addition to matching 2015_06_04, will also contain\n    # 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n    #\n    # to reduce noise, remove date matches that are strict substrings of others\n    @sorted matches.filter (match) ->\n      is_submatch = false\n      for other_match in matches\n        continue if match is other_match\n        if other_match.i <= match.i and other_match.j >= match.j\n          is_submatch = true\n          break\n      not is_submatch\n\n  map_ints_to_dmy: (ints) ->\n    # given a 3-tuple, discard if:\n    #   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n    #   middle int is zero\n    #   any int is over the max allowable year\n    #   any int is over two digits but under the min allowable year\n    #   2 ints are over 31, the max allowable day\n    #   2 ints are zero\n    #   all ints are over 12, the max allowable month\n    return if ints[1] > 31 or ints[1] <= 0\n    over_12 = 0\n    over_31 = 0\n    under_1 = 0\n    for int in ints\n      return if 99 < int < DATE_MIN_YEAR or int > DATE_MAX_YEAR\n      over_31 += 1 if int > 31\n      over_12 += 1 if int > 12\n      under_1 += 1 if int <= 0\n    return if over_31 >= 2 or over_12 == 3 or under_1 >= 2\n\n    # first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    possible_year_splits = [\n      [ints[2], ints[0..1]] # year last\n      [ints[0], ints[1..2]] # year first\n    ]\n    for [y, rest] in possible_year_splits\n      if DATE_MIN_YEAR <= y <= DATE_MAX_YEAR\n        dm = @map_ints_to_dm rest\n        if dm?\n          return {\n            year: y\n            month: dm.month\n            day: dm.day\n          }\n        else\n          # for a candidate that includes a four-digit year,\n          # when the remaining ints don't match to a day and month,\n          # it is not a date.\n          return\n\n    # given no four-digit year, two digit years are the most flexible int to match, so\n    # try to parse a day-month out of ints[0..1] or ints[1..0]\n    for [y, rest] in possible_year_splits\n      dm = @map_ints_to_dm rest\n      if dm?\n        y = @two_to_four_digit_year y\n        return {\n          year: y\n          month: dm.month\n          day: dm.day\n        }\n\n  map_ints_to_dm: (ints) ->\n    for [d, m] in [ints, ints.slice().reverse()]\n      if 1 <= d <= 31 and 1 <= m <= 12\n        return {\n          day: d\n          month: m\n        }\n\n  two_to_four_digit_year: (year) ->\n    if year > 99\n      year\n    else if year > 50\n      # 87 -> 1987\n      year + 1900\n    else\n      # 15 -> 2015\n      year + 2000\n\nmodule.exports = matching\n",
    "adjacency_graphs = require('./adjacency_graphs')\n\n# on qwerty, 'g' has degree 6, being adjacent to 'ftyhbv'. '\\' has degree 1.\n# this calculates the average over all keys.\ncalc_average_degree = (graph) ->\n  average = 0\n  for key, neighbors of graph\n    average += (n for n in neighbors when n).length\n  average /= (k for k,v of graph).length\n  average\n\nBRUTEFORCE_CARDINALITY = 10\nMIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000\nMIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10\nMIN_SUBMATCH_GUESSES_MULTI_CHAR = 50\n\nscoring =\n  nCk: (n, k) ->\n    # http://blog.plover.com/math/choose.html\n    return 0 if k > n\n    return 1 if k == 0\n    r = 1\n    for d in [1..k]\n      r *= n\n      r /= d\n      n -= 1\n    r\n\n  log10: (n) -> Math.log(n) / Math.log(10) # IE doesn't support Math.log10 :(\n  log2:  (n) -> Math.log(n) / Math.log(2)\n\n  factorial: (n) ->\n    # unoptimized, called only on small n\n    return 1 if n < 2\n    f = 1\n    f *= i for i in [2..n]\n    f\n\n  # ------------------------------------------------------------------------------\n  # search --- most guessable match sequence -------------------------------------\n  # ------------------------------------------------------------------------------\n  #\n  # takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  # minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  # for a length-n password with m candidate matches. l_max is the maximum optimal\n  # sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  # search terminates rapidly.\n  #\n  # the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  # minimizes the following function:\n  #\n  #    g = l! * Product(m.guesses for m in sequence) + D^(l - 1)\n  #\n  # where l is the length of the sequence.\n  #\n  # the factorial term is the number of ways to order l patterns.\n  #\n  # the D^(l-1) term is another length penalty, roughly capturing the idea that an\n  # attacker will try lower-length sequences first before trying length-l sequences.\n  #\n  # for example, consider a sequence that is date-repeat-dictionary.\n  #  - an attacker would need to try other date-repeat-dictionary combinations,\n  #    hence the product term.\n  #  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  #    ..., hence the factorial term.\n  #  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  #    sequences before length-3. assuming at minimum D guesses per pattern type,\n  #    D^(l-1) approximates Sum(D^i for i in [1..l-1]\n  #\n  # ------------------------------------------------------------------------------\n\n  most_guessable_match_sequence: (password, matches, _exclude_additive=false) ->\n\n    n = password.length\n\n    # partition matches into sublists according to ending index j\n    matches_by_j = ([] for _ in [0...n])\n    for m in matches\n      matches_by_j[m.j].push m\n    # small detail: for deterministic output, sort each sublist by i.\n    for lst in matches_by_j\n      lst.sort (m1, m2) -> m1.i - m2.i\n\n    optimal =\n      # optimal.m[k][l] holds final match in the best length-l match sequence covering the\n      # password prefix up to k, inclusive.\n      # if there is no length-l sequence that scores better (fewer guesses) than\n      # a shorter match sequence spanning the same prefix, optimal.m[k][l] is undefined.\n      m:  ({} for _ in [0...n])\n\n      # same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      # optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: ({} for _ in [0...n])\n\n      # same structure as optimal.m -- holds the overall metric.\n      g:  ({} for _ in [0...n])\n\n    # helper: considers whether a length-l sequence ending at match m is better (fewer guesses)\n    # than previously encountered sequences, updating state if so.\n    update = (m, l) =>\n      k = m.j\n      pi = @estimate_guesses m, password\n      if l > 1\n        # we're considering a length-l sequence ending with match m:\n        # obtain the product term in the minimization function by multiplying m's guesses\n        # by the product of the length-(l-1) sequence ending just before m, at m.i - 1.\n        pi *= optimal.pi[m.i - 1][l - 1]\n      # calculate the minimization func\n      g = @factorial(l) * pi\n      unless _exclude_additive\n        g += Math.pow(MIN_GUESSES_BEFORE_GROWING_SEQUENCE, l - 1)\n      # update state if new best.\n      # first see if any competing sequences covering this prefix, with l or fewer matches,\n      # fare better than this sequence. if so, skip it and return.\n      for competing_l, competing_g of optimal.g[k]\n        continue if competing_l > l\n        return if competing_g <= g\n      # this sequence might be part of the final optimal sequence.\n      optimal.g[k][l] = g\n      optimal.m[k][l] = m\n      optimal.pi[k][l] = pi\n\n    # helper: evaluate bruteforce matches ending at k.\n    bruteforce_update = (k) =>\n      # see if a single bruteforce match spanning the k-prefix is optimal.\n      m = make_bruteforce_match(0, k)\n      update(m, 1)\n      for i in [1..k]\n        # generate k bruteforce matches, spanning from (i=1, j=k) up to (i=k, j=k).\n        # see if adding these new matches to any of the sequences in optimal[i-1]\n        # leads to new bests.\n        m = make_bruteforce_match(i, k)\n        for l, last_m of optimal.m[i-1]\n          l = parseInt(l)\n          # corner: an optimal sequence will never have two adjacent bruteforce matches.\n          # it is strictly better to have a single bruteforce match spanning the same region:\n          # same contribution to the guess product with a lower length.\n          # --> safe to skip those cases.\n          continue if last_m.pattern == 'bruteforce'\n          # try adding m to this length-l sequence.\n          update(m, l + 1)\n\n    # helper: make bruteforce match objects spanning i to j, inclusive.\n    make_bruteforce_match = (i, j) =>\n      pattern: 'bruteforce'\n      token: password[i..j]\n      i: i\n      j: j\n\n    # helper: step backwards through optimal.m starting at the end,\n    # constructing the final optimal match sequence.\n    unwind = (n) =>\n      optimal_match_sequence = []\n      k = n - 1\n      # find the final best sequence length and score\n      l = undefined\n      g = Infinity\n      for candidate_l, candidate_g of optimal.g[k]\n        if candidate_g < g\n          l = candidate_l\n          g = candidate_g\n\n      while k >= 0\n        m = optimal.m[k][l]\n        optimal_match_sequence.unshift m\n        k = m.i - 1\n        l--\n      optimal_match_sequence\n\n    for k in [0...n]\n      for m in matches_by_j[k]\n        if m.i > 0\n          for l of optimal.m[m.i - 1]\n            l = parseInt(l)\n            update(m, l + 1)\n        else\n          update(m, 1)\n      bruteforce_update(k)\n    optimal_match_sequence = unwind(n)\n    optimal_l = optimal_match_sequence.length\n\n    # corner: empty password\n    if password.length == 0\n      guesses = 1\n    else\n      guesses = optimal.g[n - 1][optimal_l]\n\n    # final result object\n    password: password\n    guesses: guesses\n    guesses_log10: @log10 guesses\n    sequence: optimal_match_sequence\n\n  # ------------------------------------------------------------------------------\n  # guess estimation -- one function per match pattern ---------------------------\n  # ------------------------------------------------------------------------------\n\n  estimate_guesses: (match, password) ->\n    return match.guesses if match.guesses? # a match's guess estimate doesn't change. cache it.\n    min_guesses = 1\n    if match.token.length < password.length\n      min_guesses = if match.token.length == 1\n        MIN_SUBMATCH_GUESSES_SINGLE_CHAR\n      else\n        MIN_SUBMATCH_GUESSES_MULTI_CHAR\n    estimation_functions =\n      bruteforce: @bruteforce_guesses\n      dictionary: @dictionary_guesses\n      spatial:    @spatial_guesses\n      repeat:     @repeat_guesses\n      sequence:   @sequence_guesses\n      regex:      @regex_guesses\n      date:       @date_guesses\n    guesses = estimation_functions[match.pattern].call this, match\n    match.guesses = Math.max guesses, min_guesses\n    match.guesses_log10 = @log10 match.guesses\n    match.guesses\n\n  bruteforce_guesses: (match) ->\n    guesses = Math.pow BRUTEFORCE_CARDINALITY, match.token.length\n    if guesses == Number.POSITIVE_INFINITY\n        guesses = Number.MAX_VALUE;\n    # small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n    # submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n    min_guesses = if match.token.length == 1\n      MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1\n    else\n      MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1\n    Math.max guesses, min_guesses\n\n  repeat_guesses: (match) ->\n    match.base_guesses * match.repeat_count\n\n  sequence_guesses: (match) ->\n    first_chr = match.token.charAt(0)\n    # lower guesses for obvious starting points\n    if first_chr in ['a', 'A', 'z', 'Z', '0', '1', '9']\n      base_guesses = 4\n    else\n      if first_chr.match /\\d/\n        base_guesses = 10 # digits\n      else\n        # could give a higher base for uppercase,\n        # assigning 26 to both upper and lower sequences is more conservative.\n        base_guesses = 26\n    if not match.ascending\n      # need to try a descending sequence in addition to every ascending sequence ->\n      # 2x guesses\n      base_guesses *= 2\n    base_guesses * match.token.length\n\n  MIN_YEAR_SPACE: 20\n  REFERENCE_YEAR: new Date().getFullYear()\n\n  regex_guesses: (match) ->\n    char_class_bases =\n      alpha_lower:  26\n      alpha_upper:  26\n      alpha:        52\n      alphanumeric: 62\n      digits:       10\n      symbols:      33\n    if match.regex_name of char_class_bases\n      Math.pow(char_class_bases[match.regex_name], match.token.length)\n    else switch match.regex_name\n      when 'recent_year'\n        # conservative estimate of year space: num years from REFERENCE_YEAR.\n        # if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n        year_space = Math.abs parseInt(match.regex_match[0]) - @REFERENCE_YEAR\n        year_space = Math.max year_space, @MIN_YEAR_SPACE\n        year_space\n\n  date_guesses: (match) ->\n    # base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n    year_space = Math.max(Math.abs(match.year - @REFERENCE_YEAR), @MIN_YEAR_SPACE)\n    guesses = year_space * 365\n    # add factor of 4 for separator selection (one of ~4 choices)\n    guesses *= 4 if match.separator\n    guesses\n\n  KEYBOARD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.qwerty)\n  # slightly different for keypad/mac keypad, but close enough\n  KEYPAD_AVERAGE_DEGREE: calc_average_degree(adjacency_graphs.keypad)\n\n  KEYBOARD_STARTING_POSITIONS: (k for k,v of adjacency_graphs.qwerty).length\n  KEYPAD_STARTING_POSITIONS: (k for k,v of adjacency_graphs.keypad).length\n\n  spatial_guesses: (match) ->\n    if match.graph in ['qwerty', 'dvorak']\n      s = @KEYBOARD_STARTING_POSITIONS\n      d = @KEYBOARD_AVERAGE_DEGREE\n    else\n      s = @KEYPAD_STARTING_POSITIONS\n      d = @KEYPAD_AVERAGE_DEGREE\n    guesses = 0\n    L = match.token.length\n    t = match.turns\n    # estimate the number of possible patterns w/ length L or less with t turns or less.\n    for i in [2..L]\n      possible_turns = Math.min(t, i - 1)\n      for j in [1..possible_turns]\n        guesses += @nCk(i - 1, j - 1) * s * Math.pow(d, j)\n    # add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n    # math is similar to extra guesses of l33t substitutions in dictionary matches.\n    if match.shifted_count\n      S = match.shifted_count\n      U = match.token.length - match.shifted_count # unshifted count\n      if S == 0 or U == 0\n        guesses *= 2\n      else\n        shifted_variations = 0\n        shifted_variations += @nCk(S + U, i) for i in [1..Math.min(S, U)]\n        guesses *= shifted_variations\n    guesses\n\n  dictionary_guesses: (match) ->\n    match.base_guesses = match.rank # keep these as properties for display purposes\n    match.uppercase_variations = @uppercase_variations match\n    match.l33t_variations = @l33t_variations match\n    reversed_variations = match.reversed and 2 or 1\n    match.base_guesses * match.uppercase_variations * match.l33t_variations * reversed_variations\n\n  START_UPPER: /^[A-Z][^A-Z]+$/\n  END_UPPER: /^[^A-Z]+[A-Z]$/\n  ALL_UPPER: /^[^a-z]+$/\n  ALL_LOWER: /^[^A-Z]+$/\n\n  uppercase_variations: (match) ->\n    word = match.token\n    return 1 if word.match(@ALL_LOWER) or word.toLowerCase() == word\n    # a capitalized word is the most common capitalization scheme,\n    # so it only doubles the search space (uncapitalized + capitalized).\n    # allcaps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n    for regex in [@START_UPPER, @END_UPPER, @ALL_UPPER]\n      return 2 if word.match regex\n    # otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n    # with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n    # the number of ways to lowercase U+L letters with L lowercase letters or less.\n    U = (chr for chr in word.split('') when chr.match /[A-Z]/).length\n    L = (chr for chr in word.split('') when chr.match /[a-z]/).length\n    variations = 0\n    variations += @nCk(U + L, i) for i in [1..Math.min(U, L)]\n    variations\n\n  l33t_variations: (match) ->\n    return 1 if not match.l33t\n    variations = 1\n    for subbed, unsubbed of match.sub\n      # lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n      chrs = match.token.toLowerCase().split('')\n      S = (chr for chr in chrs when chr == subbed).length   # num of subbed chars\n      U = (chr for chr in chrs when chr == unsubbed).length # num of unsubbed chars\n      if S == 0 or U == 0\n        # for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n        # treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n        # unsubbed.)\n        variations *= 2\n      else\n        # this case is similar to capitalization:\n        # with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n        p = Math.min(U, S)\n        possibilities = 0\n        possibilities += @nCk(U + S, i) for i in [1..p]\n        variations *= possibilities\n    variations\n\n  # utilities --------------------------------------------------------------------\n\nmodule.exports = scoring\n",
    "time_estimates =\n  estimate_attack_times: (guesses) ->\n    crack_times_seconds =\n      online_throttling_100_per_hour: guesses / (100 / 3600)\n      online_no_throttling_10_per_second: guesses / 10\n      offline_slow_hashing_1e4_per_second: guesses / 1e4\n      offline_fast_hashing_1e10_per_second: guesses / 1e10\n\n    crack_times_display = {}\n    for scenario, seconds of crack_times_seconds\n      crack_times_display[scenario] = @display_time seconds\n\n    crack_times_seconds: crack_times_seconds\n    crack_times_display: crack_times_display\n    score: @guesses_to_score guesses\n\n\n  guesses_to_score: (guesses) ->\n    DELTA = 5\n    if guesses < 1e3 + DELTA\n      # risky password: \"too guessable\"\n      0\n    else if guesses < 1e6 + DELTA\n      # modest protection from throttled online attacks: \"very guessable\"\n      1\n    else if guesses < 1e8 + DELTA\n      # modest protection from unthrottled online attacks: \"somewhat guessable\"\n      2\n    else if guesses < 1e10 + DELTA\n      # modest protection from offline attacks: \"safely unguessable\"\n      # assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n      3\n    else\n      # strong protection from offline attacks under same scenario: \"very unguessable\"\n      4\n\n  display_time: (seconds) ->\n    minute = 60\n    hour = minute * 60\n    day = hour * 24\n    month = day * 31\n    year = month * 12\n    century = year * 100\n    [display_num, display_str] = if seconds < 1\n      [null, 'less than a second']\n    else if seconds < minute\n      base = Math.round seconds\n      [base, \"#{base} second\"]\n    else if seconds < hour\n      base = Math.round seconds / minute\n      [base, \"#{base} minute\"]\n    else if seconds < day\n      base = Math.round seconds / hour\n      [base, \"#{base} hour\"]\n    else if seconds < month\n      base = Math.round seconds / day\n      [base, \"#{base} day\"]\n    else if seconds < year\n      base = Math.round seconds / month\n      [base, \"#{base} month\"]\n    else if seconds < century\n      base = Math.round seconds / year\n      [base, \"#{base} year\"]\n    else\n      [null, 'centuries']\n    display_str += 's' if display_num? and display_num != 1\n    display_str\n\nmodule.exports = time_estimates\n"
  ]
}